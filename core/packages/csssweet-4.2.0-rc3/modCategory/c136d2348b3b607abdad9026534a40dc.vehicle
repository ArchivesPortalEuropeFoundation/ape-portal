<?php return array (
  'unique_key' => 'category',
  'preserve_keys' => false,
  'update_object' => true,
  'related_objects' => 
  array (
    'Chunks' => 
    array (
      'b23831ef2c285b334ad3a6e73a2276cf' => 
      array (
        'preserve_keys' => false,
        'update_object' => false,
        'unique_key' => 'name',
        'class' => 'modChunk',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"csss.custom_css.scss","description":"Sample chunk only. It\'s recommended to create your own chunk(s) with a unique name(s) and set them in the saveCustomCss plugin properties.","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/* @import \'test.scss\'; *\\/\\n\\n#logo {\\n  display: block;\\n}","locked":0,"properties":"a:0:{}","static":0,"static_file":"","content":"\\/* @import \'test.scss\'; *\\/\\n\\n#logo {\\n  display: block;\\n}"}',
        'guid' => 'f88ade94df614aeceab971019665fa49',
        'native_key' => NULL,
        'signature' => 'e6472610b98de3b92fae937f8620ea8b',
      ),
    ),
    'Snippets' => 
    array (
      'c3a81430d196ddca1fb4eed84f1556ce' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"lighten","description":"","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/* \\n * lighten\\n *\\n * Output modifier that accepts a hex value and percentage (+ or -) option. \\n * Additionally, \'max\' or \'rev\' can be set, with or without a percentage. \\n *\\n * Examples:\\n * [[+color:lighten=`20`]]\\n * Lightens the $input hex color by 20%\\n *\\n * [[+color:lighten=`-30`]]\\n * Darkens the $input color by 30%\\n *\\n * [[+color:lighten=`max`]]\\n * If the $input value is above the $threshold value, \'ffffff\' will be\\n * returned, else \'000000\' will be returned.\\n *\\n * [[+color:lighten=`rev60`]]\\n * This would output the reverse of the $input hex (white or black) * 60%\\n * (so the result would be more of a medium gray)\\n *\\n * Variables other than $options must be set in snippet properties tab if \\n * used as output modifier.\\n *\\n *\\/\\n\\n\\/\\/ Get values\\n$input = isset($input) ? $input : null;\\nif( !$input ) return;\\n$options = isset($options) ? $options : \'0\';\\n\\n\\/\\/ Default method for percentage calculations. Can be \'input\', \'spectrum\', or \'average\'\\n$availOpts = array(\'input\',\'spectrum\',\'average\');\\n$percOpt = $modx->getOption(\'percOpt\',$scriptProperties,\'input\');\\nif ( !in_array($percOpt, $availOpts) ) $percOpt = \'input\';\\n\\n\\/\\/ Default threshold color for additional options\\n$threshold = $modx->getOption(\'threshold\',$scriptProperties,\'999999\');\\nif( !preg_match(\'\\/[a-fA-F0-9]{6}\\/\',$threshold) ) $threshold = \'999999\';\\n\\n\\/\\/ Set comparison values for additional options\\n$inputDec = hexdec($input);\\n$threshold = hexdec($threshold);\\nif( $inputDec > $threshold ) { \\n  $lightInput = true;\\n  $darkInput = false;\\n} else {\\n  $darkInput = true;\\n  $lightInput = false;\\n}\\n\\n\\/\\/ Set additional options\\npreg_match(\'\\/(max)\\/\',$options,$max);\\npreg_match(\'\\/(rev)\\/\',$options,$rev);\\n$options = preg_replace(\'\\/[^0-9-]\\/\',\'\',$options);\\n\\n\\/\\/ check stuff\\nif( substr($input, 0, 1) === \'#\' ) $input = substr($input, 1, 6);\\n$len = strlen($input);\\nif( $len !== 3 && $len !== 6 ) return \'\\/* 3 or 6 hex characters required *\\/\';\\n$bits = str_split($input);\\nforeach($bits as $bit) { \\n    if( !preg_match(\'\\/[0-9a-fA-F]\\/\',$bit) ) return \\"\\/* invalid hex character \'$bit\' *\\/\\";\\n}\\n\\n\\/\\/ make color constituents\\nif( $len === 3 ) {\\n    $arr[0] = $bits[0] . $bits[0];\\n    $arr[1] = $bits[1] . $bits[1];\\n    $arr[2] = $bits[2] . $bits[2];\\n}\\nif( $len === 6 ) {\\n    $arr[0] = $bits[0] . $bits[1];\\n    $arr[1] = $bits[2] . $bits[3];\\n    $arr[2] = $bits[4] . $bits[5];\\n}\\n\\n\\/\\/ Shortcuts if using \'max\' or \'rev\' without percentage\\nif( !$options ) {\\n    if( $max ) {\\n        if( $lightInput ) return \'ffffff\';\\n        if( $darkInput ) return \'000000\';\\n    }\\n    if( $rev ) {\\n        if( $lightInput ) return \'000000\';\\n        if( $darkInput ) return \'ffffff\';\\n    }\\n} else {\\n    \\/\\/ If ($options) we\'ll need these \\n    $dec = array();\\n    $perc = (intval($options,10) \\/ 100);\\n\\n    \\/\\/ These are for special cases\\n    if( $max || $rev ) {\\n        $perc = abs(min($perc,1));\\n        $wht = dechex(255 * $perc);\\n        $wht = str_pad($wht,2,\'0\',STR_PAD_LEFT); \\n        $wht = str_repeat($wht,3); \\n        $blk = dechex( ( 255 - (255 * $perc) ) ); \\n        $blk = str_pad($blk,2,\'0\',STR_PAD_LEFT);\\n        $blk = str_repeat($blk,3);\\n    }\\n    if( $max ) {\\n        if( $lightInput ) return $wht;\\n        if( $darkInput ) return $blk;\\n    }\\n    if( $rev ) {\\n        if( $lightInput ) return $blk;\\n        if( $darkInput ) return $wht;\\n    }\\n}\\n\\n\\/\\/ Lighten or darken the input\\nfor($i=0;$i<3;$i++) {\\n    $dec = hexdec($arr[$i]);\\n    if( $percOpt === \'input\') $amount = round($dec * $perc);\\n    if( $percOpt === \'spectrum\') $amount = round(255 * $perc);\\n    if( $percOpt === \'average\') $amount = round(($dec + 255) * ($perc \\/ 2));\\n    $sum = $dec + $amount;\\n\\n    if($sum > 255) { $result[$i] = \'255\'; }\\n    elseif($sum < 0) { $result[$i] = \'0\'; }\\n    else $result[$i] = $sum;\\n\\n    $hex[$i] = dechex($result[$i]);\\n    $hex[$i] = str_pad($hex[$i],2,\'0\',STR_PAD_LEFT);\\n}\\n\\n\\/\\/ return processed hex color value\\nreturn implode($hex);","locked":0,"properties":"a:2:{s:7:\\"percOpt\\";a:7:{s:4:\\"name\\";s:7:\\"percOpt\\";s:4:\\"desc\\";s:40:\\"Can be \'input\', \'spectrum\' or \'average\'.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:5:\\"input\\";s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:9:\\"threshold\\";a:7:{s:4:\\"name\\";s:9:\\"threshold\\";s:4:\\"desc\\";s:75:\\"Valid, 6-character hex against which to evaluate light and dark hex values.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:6:\\"999999\\";s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:0:\\"\\";}}","moduleguid":"","static":0,"static_file":"","content":"\\/* \\n * lighten\\n *\\n * Output modifier that accepts a hex value and percentage (+ or -) option. \\n * Additionally, \'max\' or \'rev\' can be set, with or without a percentage. \\n *\\n * Examples:\\n * [[+color:lighten=`20`]]\\n * Lightens the $input hex color by 20%\\n *\\n * [[+color:lighten=`-30`]]\\n * Darkens the $input color by 30%\\n *\\n * [[+color:lighten=`max`]]\\n * If the $input value is above the $threshold value, \'ffffff\' will be\\n * returned, else \'000000\' will be returned.\\n *\\n * [[+color:lighten=`rev60`]]\\n * This would output the reverse of the $input hex (white or black) * 60%\\n * (so the result would be more of a medium gray)\\n *\\n * Variables other than $options must be set in snippet properties tab if \\n * used as output modifier.\\n *\\n *\\/\\n\\n\\/\\/ Get values\\n$input = isset($input) ? $input : null;\\nif( !$input ) return;\\n$options = isset($options) ? $options : \'0\';\\n\\n\\/\\/ Default method for percentage calculations. Can be \'input\', \'spectrum\', or \'average\'\\n$availOpts = array(\'input\',\'spectrum\',\'average\');\\n$percOpt = $modx->getOption(\'percOpt\',$scriptProperties,\'input\');\\nif ( !in_array($percOpt, $availOpts) ) $percOpt = \'input\';\\n\\n\\/\\/ Default threshold color for additional options\\n$threshold = $modx->getOption(\'threshold\',$scriptProperties,\'999999\');\\nif( !preg_match(\'\\/[a-fA-F0-9]{6}\\/\',$threshold) ) $threshold = \'999999\';\\n\\n\\/\\/ Set comparison values for additional options\\n$inputDec = hexdec($input);\\n$threshold = hexdec($threshold);\\nif( $inputDec > $threshold ) { \\n  $lightInput = true;\\n  $darkInput = false;\\n} else {\\n  $darkInput = true;\\n  $lightInput = false;\\n}\\n\\n\\/\\/ Set additional options\\npreg_match(\'\\/(max)\\/\',$options,$max);\\npreg_match(\'\\/(rev)\\/\',$options,$rev);\\n$options = preg_replace(\'\\/[^0-9-]\\/\',\'\',$options);\\n\\n\\/\\/ check stuff\\nif( substr($input, 0, 1) === \'#\' ) $input = substr($input, 1, 6);\\n$len = strlen($input);\\nif( $len !== 3 && $len !== 6 ) return \'\\/* 3 or 6 hex characters required *\\/\';\\n$bits = str_split($input);\\nforeach($bits as $bit) { \\n    if( !preg_match(\'\\/[0-9a-fA-F]\\/\',$bit) ) return \\"\\/* invalid hex character \'$bit\' *\\/\\";\\n}\\n\\n\\/\\/ make color constituents\\nif( $len === 3 ) {\\n    $arr[0] = $bits[0] . $bits[0];\\n    $arr[1] = $bits[1] . $bits[1];\\n    $arr[2] = $bits[2] . $bits[2];\\n}\\nif( $len === 6 ) {\\n    $arr[0] = $bits[0] . $bits[1];\\n    $arr[1] = $bits[2] . $bits[3];\\n    $arr[2] = $bits[4] . $bits[5];\\n}\\n\\n\\/\\/ Shortcuts if using \'max\' or \'rev\' without percentage\\nif( !$options ) {\\n    if( $max ) {\\n        if( $lightInput ) return \'ffffff\';\\n        if( $darkInput ) return \'000000\';\\n    }\\n    if( $rev ) {\\n        if( $lightInput ) return \'000000\';\\n        if( $darkInput ) return \'ffffff\';\\n    }\\n} else {\\n    \\/\\/ If ($options) we\'ll need these \\n    $dec = array();\\n    $perc = (intval($options,10) \\/ 100);\\n\\n    \\/\\/ These are for special cases\\n    if( $max || $rev ) {\\n        $perc = abs(min($perc,1));\\n        $wht = dechex(255 * $perc);\\n        $wht = str_pad($wht,2,\'0\',STR_PAD_LEFT); \\n        $wht = str_repeat($wht,3); \\n        $blk = dechex( ( 255 - (255 * $perc) ) ); \\n        $blk = str_pad($blk,2,\'0\',STR_PAD_LEFT);\\n        $blk = str_repeat($blk,3);\\n    }\\n    if( $max ) {\\n        if( $lightInput ) return $wht;\\n        if( $darkInput ) return $blk;\\n    }\\n    if( $rev ) {\\n        if( $lightInput ) return $blk;\\n        if( $darkInput ) return $wht;\\n    }\\n}\\n\\n\\/\\/ Lighten or darken the input\\nfor($i=0;$i<3;$i++) {\\n    $dec = hexdec($arr[$i]);\\n    if( $percOpt === \'input\') $amount = round($dec * $perc);\\n    if( $percOpt === \'spectrum\') $amount = round(255 * $perc);\\n    if( $percOpt === \'average\') $amount = round(($dec + 255) * ($perc \\/ 2));\\n    $sum = $dec + $amount;\\n\\n    if($sum > 255) { $result[$i] = \'255\'; }\\n    elseif($sum < 0) { $result[$i] = \'0\'; }\\n    else $result[$i] = $sum;\\n\\n    $hex[$i] = dechex($result[$i]);\\n    $hex[$i] = str_pad($hex[$i],2,\'0\',STR_PAD_LEFT);\\n}\\n\\n\\/\\/ return processed hex color value\\nreturn implode($hex);"}',
        'guid' => '0764720ffe0098641ff7b3ab9ac725e0',
        'native_key' => NULL,
        'signature' => 'f7ea99bbc4e8892307d3db5ee7e80cab',
      ),
      'f1fcc8d9679f2f2722a7cbea6be1e026' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"modval","description":"","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/* \\n * modval\\n *\\n * Output modifier that accepts a numeric value and modifies it. \\n * Identifies strings as units and separates them. \\n *\\n * Examples:\\n * [[modval?input=`4px`&options=`*3`]]\\n * \'12px\'\\n *\\n * [[+inches:modval=`\\/2`]]\\n * Where the value of the placeholder is \'18 inches\'\\n * \'9 inches\'\\n *\\/\\n\\n\\/* Get input: numbers go in an array, everything else is assumed\\n * as a unit.\\n *\\/\\n$input = isset($input) ? $input : \'\';\\nif( !$input ) return;\\npreg_match(\'\\/([0-9.]+)\\/\',$input,$valArr);\\n$unit = preg_replace(\'\\/([0-9.]+)\\/\',\'\',$input);\\n\\n\\/\\/ Get options: numbers go in one array, operators in another\\npreg_match(\'\\/([0-9.]+)\\/\',$options,$optValArr);\\npreg_match(\'\\/[\\\\+\\\\-\\\\*\\\\\\/]\\/\',$options,$op);\\n\\n\\/\\/ Default operator\\nif( !$op ) $op[0] = \'+\';\\n\\n\\/\\/ Simple math only\\nif( $op[0] == \'+\' ) $val = ($valArr[0] + $optValArr[0]);\\nif( $op[0] == \'-\' ) $val = ($valArr[0] - $optValArr[0]);\\nif( $op[0] == \'*\' ) $val = ($valArr[0] * $optValArr[0]);\\nif( $op[0] == \'\\/\' ) $val = ($valArr[0] \\/ $optValArr[0]);\\n\\n\\/\\/ Results\\nreturn $val . $unit;","locked":0,"properties":"a:0:{}","moduleguid":"","static":0,"static_file":"","content":"\\/* \\n * modval\\n *\\n * Output modifier that accepts a numeric value and modifies it. \\n * Identifies strings as units and separates them. \\n *\\n * Examples:\\n * [[modval?input=`4px`&options=`*3`]]\\n * \'12px\'\\n *\\n * [[+inches:modval=`\\/2`]]\\n * Where the value of the placeholder is \'18 inches\'\\n * \'9 inches\'\\n *\\/\\n\\n\\/* Get input: numbers go in an array, everything else is assumed\\n * as a unit.\\n *\\/\\n$input = isset($input) ? $input : \'\';\\nif( !$input ) return;\\npreg_match(\'\\/([0-9.]+)\\/\',$input,$valArr);\\n$unit = preg_replace(\'\\/([0-9.]+)\\/\',\'\',$input);\\n\\n\\/\\/ Get options: numbers go in one array, operators in another\\npreg_match(\'\\/([0-9.]+)\\/\',$options,$optValArr);\\npreg_match(\'\\/[\\\\+\\\\-\\\\*\\\\\\/]\\/\',$options,$op);\\n\\n\\/\\/ Default operator\\nif( !$op ) $op[0] = \'+\';\\n\\n\\/\\/ Simple math only\\nif( $op[0] == \'+\' ) $val = ($valArr[0] + $optValArr[0]);\\nif( $op[0] == \'-\' ) $val = ($valArr[0] - $optValArr[0]);\\nif( $op[0] == \'*\' ) $val = ($valArr[0] * $optValArr[0]);\\nif( $op[0] == \'\\/\' ) $val = ($valArr[0] \\/ $optValArr[0]);\\n\\n\\/\\/ Results\\nreturn $val . $unit;"}',
        'guid' => '38b164fd2781eee4e27aace717b6b567',
        'native_key' => NULL,
        'signature' => '96e1da813693f3a2a500de0ffd1d75ae',
      ),
      '3f0c14e983a66276bf829ca0ca68c01b' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"prefix","description":"","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/* \\n * prefix\\n *\\n * Output modifier that adds basic browser prefixes to $input strings \\n *\\n * Examples:\\n * [[+my_radius_css:prefix]]\\n * Where the value of the placeholder is \'border-radius: 3px;\'\\n * -webkit-border-radius: 3px;\\n * -moz-border-radius: 3px;\\n * border-radius: 3px;\\n * \\n * [[prefix?to=`transition: all 300ms ease;` &options=`all`]]\\n * -webkit-transition: all 300ms ease;\\n * -moz-transition: all 300ms ease;\\n * -ms-transition: all 300ms ease;\\n * -o-transition: all 300ms ease;\\n * transition: all 300ms ease;\\n *\\/\\n\\n\\/\\/ Get input\\n$input = isset($input) ? $input : \'\';\\n\\n\\/\\/ If $to property is set, use that instead\\n$input = (isset($to)) ? $to : $input;\\n\\n\\/\\/ Check it\\nif ( !$input ) return;\\n\\n\\/\\/ Get options and defaults\\n$options = isset($options) ? $options : \'webkit,moz\';\\nif ( $options === \'all\' ) $options = \'webkit,moz,ms,o\';\\n\\n\\/\\/ Which prefix?\\n$prefixes = [\'webkit\',\'moz\',\'ms\',\'o\'];\\n$output = \'\';\\n$selects = explode(\',\',$options);\\nforeach($selects as $select) {\\n    if( in_array($select,$prefixes) ) $output .= \\"-$select-$input\\" . PHP_EOL;\\n}\\n$output .= $input;\\n\\nreturn $output;","locked":0,"properties":"a:0:{}","moduleguid":"","static":0,"static_file":"","content":"\\/* \\n * prefix\\n *\\n * Output modifier that adds basic browser prefixes to $input strings \\n *\\n * Examples:\\n * [[+my_radius_css:prefix]]\\n * Where the value of the placeholder is \'border-radius: 3px;\'\\n * -webkit-border-radius: 3px;\\n * -moz-border-radius: 3px;\\n * border-radius: 3px;\\n * \\n * [[prefix?to=`transition: all 300ms ease;` &options=`all`]]\\n * -webkit-transition: all 300ms ease;\\n * -moz-transition: all 300ms ease;\\n * -ms-transition: all 300ms ease;\\n * -o-transition: all 300ms ease;\\n * transition: all 300ms ease;\\n *\\/\\n\\n\\/\\/ Get input\\n$input = isset($input) ? $input : \'\';\\n\\n\\/\\/ If $to property is set, use that instead\\n$input = (isset($to)) ? $to : $input;\\n\\n\\/\\/ Check it\\nif ( !$input ) return;\\n\\n\\/\\/ Get options and defaults\\n$options = isset($options) ? $options : \'webkit,moz\';\\nif ( $options === \'all\' ) $options = \'webkit,moz,ms,o\';\\n\\n\\/\\/ Which prefix?\\n$prefixes = [\'webkit\',\'moz\',\'ms\',\'o\'];\\n$output = \'\';\\n$selects = explode(\',\',$options);\\nforeach($selects as $select) {\\n    if( in_array($select,$prefixes) ) $output .= \\"-$select-$input\\" . PHP_EOL;\\n}\\n$output .= $input;\\n\\nreturn $output;"}',
        'guid' => 'c0446fe8cecaadf6273966a00b94b45e',
        'native_key' => NULL,
        'signature' => 'de88fa161df4c4716d6444191fc59916',
      ),
    ),
    'Plugins' => 
    array (
      '8124106b6befff81128efbcaf25307b0' => 
      array (
        'unique_key' => 'name',
        'preserve_keys' => false,
        'update_object' => true,
        'related_objects' => 
        array (
          'PluginEvents' => 
          array (
            'f48ef9a15ddb9a6a9ebcd2f0f1e7f4c9' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnSiteRefresh","priority":0,"propertyset":0}',
              'guid' => 'd9faa75b92469fc7773fdc024a925fd3',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnSiteRefresh',
              ),
              'signature' => 'dc8fa07a763a83f6ccd754fcadf85b92',
            ),
            '6208da9c62a85258f0e3e796ebe43df2' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnChunkFormSave","priority":0,"propertyset":0}',
              'guid' => 'effeab35d63fcb0028e528c2ee935fe0',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnChunkFormSave',
              ),
              'signature' => 'b01e757efd912a16c7a69145f95def8c',
            ),
          ),
        ),
        'related_object_attributes' => 
        array (
          'PluginEvents' => 
          array (
            'preserve_keys' => true,
            'update_object' => false,
            'unique_key' => 
            array (
              0 => 'pluginid',
              1 => 'event',
            ),
          ),
        ),
        'class' => 'modPlugin',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"saveCustomCss","description":"","editor_type":0,"category":0,"cache_type":0,"plugincode":"\\/**\\n * saveCustomCss\\n * @author @sepiariver\\n * Copyright 2013 - 2015 by YJ Tso <yj@modx.com> <info@sepiariver.com>\\n *\\n * saveCustomCss and cssSweet is free software;\\n * you can redistribute it and\\/or modify it under the terms of the GNU General\\n * Public License as published by the Free Software Foundation;\\n * either version 2 of the License, or (at your option) any later version.\\n *\\n * saveCustomCss and cssSweet is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License along with\\n * saveCustomCss and cssSweet; if not, write to the Free Software Foundation, Inc.,\\n * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\\n *\\n * @package cssSweet\\n *\\n *\\/\\n\\n\\/\\/ Never fire on the front end\\nif ($modx->context->get(\'key\') !== \'mgr\') return;\\n\\n\\/\\/ In case the wrong event is enabled in plugin properties\\n$allowedEvents = array(\'OnSiteRefresh\',\'OnChunkFormSave\',\'ClientConfig_ConfigChange\');\\nif (!in_array($modx->event->name, $allowedEvents)) return;\\n\\n\\/\\/ Grab the cssSweet class\\n$csssweet = null;\\n$cssSweetPath = $modx->getOption(\'csssweet.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/csssweet\\/\');\\n$cssSweetPath .= \'model\\/csssweet\\/\';\\nif (file_exists($cssSweetPath . \'csssweet.class.php\')) $csssweet = $modx->getService(\'csssweet\', \'CssSweet\', $cssSweetPath);\\n\\nif (!$csssweet || !($csssweet instanceof CssSweet)) {\\n\\n    $modx->log(modX::LOG_LEVEL_ERROR, \'[SaveCustomCss] could not load the required csssweet class!\');\\n\\treturn;\\n\\n}\\n\\n\\/\\/ Dev mode option\\n$mode = $modx->getOption(\'dev_mode\', $scriptProperties, \'custom\', true);\\n\\/\\/ Letting folks know what\'s going on\\n$modx->log(modX::LOG_LEVEL_INFO, \'saveCustomCss plugin is running in mode: \' . $mode);\\n\\n\\/\\/ Override properties with mode props\\n$properties = $scriptProperties;\\nforeach ($properties as $key => $val) {\\n    \\/\\/ skip any mode props\\n    if (strpos($key, $mode) === 0) continue;\\n    \\/\\/ these are standard scriptProperties\\n    $properties[$key] = (isset($properties[$mode . \'_\' . $key])) ? $properties[$mode . \'_\' . $key] : $val;\\n}\\n\\n\\/\\/ Specify a comma-separated list of chunk names in plugin properties\\n$chunks = $csssweet->explodeAndClean($modx->getOption(\'scss_chunks\', $properties, \'\'));\\n\\/\\/ If no chunk names specified, there\'s nothing to do.\\nif (empty($chunks)) {\\n    $modx->log(modX::LOG_LEVEL_WARN, \'No chunks were set in the saveCustomCss plugin property scss_chunks. No action performed.\');\\n    return;\\n}\\n\\n\\/\\/ Don\'t run this for every ChunkSave event\\nif ($modx->event->name === \'OnChunkFormSave\' && !in_array($chunk->get(\'name\'), $chunks)) return;\\n\\n\\/\\/ Specify an output file name in plugin properties\\n$filename = $modx->getOption(\'css_filename\', $properties, \'\');\\nif (empty($filename)) return;\\n\\n\\/\\/ Optionally choose an output format if not minified\\n$css_output_format = $modx->getOption(\'css_output_format\', $properties, \'Expanded\');\\n$css_output_format_options = array(\'Expanded\',\'Nested\',\'Compact\');\\nif (!in_array($css_output_format, $css_output_format_options)) $css_output_format = \'Expanded\';\\n\\n\\/\\/ Optionally minify the output, defaults to \'true\'\\n$minify_custom_css = (bool) $modx->getOption(\'minify_custom_css\', $properties, true);\\n$css_output_format = ($minify_custom_css) ? \'Compressed\' : $css_output_format;\\n\\n\\/\\/ Strip CSS comment blocks; defaults to \'false\'\\n$strip_comments = (bool) $modx->getOption(\'strip_css_comment_blocks\', $properties, false);\\n$css_output_format = ($minify_custom_css && $strip_comments) ? \'Crunched\' : $css_output_format;\\n\\n\\/\\/ Optionally set base_path for scss imports\\n$scss_import_paths = $modx->getOption(\'scss_import_paths\', $properties, \'\');\\n$scss_import_paths = (empty($scss_import_paths)) ? array() : $csssweet->explodeAndClean($scss_import_paths);\\n\\n\\/\\/ Get the output path; construct fallback; log for debugging\\n$csssCustomCssPath = $modx->getOption(\'css_path\', $properties, \'\');\\nif (empty($csssCustomCssPath)) $csssCustomCssPath = $modx->getOption(\'assets_path\') . \'components\\/csssweet\\/\' . $mode . \'\\/\';\\n$modx->log(modX::LOG_LEVEL_INFO, \'$csssCustomCssPath is: \' . $csssCustomCssPath . \' on line: \' . __LINE__);\\n$csssCustomCssPath = rtrim($csssCustomCssPath, \'\\/\') . \'\\/\';\\n\\n\\/\\/ If directory exists but isn\'t writable we have a problem, Houston\\nif (file_exists($csssCustomCssPath) && !is_writable($csssCustomCssPath)) {\\n    $modx->log(modX::LOG_LEVEL_ERROR, \'The directory at \' . $csssCustomCssPath . \'is not writable!\',\'\',\'saveCustomCss\');\\n    return;\\n}\\n\\n\\/\\/ Check if directory exists, if not, create it\\nif (!file_exists($csssCustomCssPath)) {\\n    if (mkdir($csssCustomCssPath, 0755, true)) {\\n        $modx->log(modX::LOG_LEVEL_INFO, \'Directory created at \' . $csssCustomCssPath, \'\', \'saveCustomCss\');\\n    } else {\\n        $modx->log(modX::LOG_LEVEL_ERROR, \'Directory could not be created at \' . $csssCustomCssPath, \'\', \'saveCustomCss\');\\n        return;\\n    }\\n}\\n\\n\\/\\/ Initialize settings array\\n$settings = array();\\n\\n\\/\\/ Get context settings\\n$settings_ctx = $modx->getOption(\'context_settings_context\', $properties, \'\');\\nif (!empty($settings_ctx)) {\\n    $settings_ctx = $modx->getContext($settings_ctx);\\n    if ($settings_ctx && is_array($settings_ctx->config)) $settings = array_merge($settings, $settings_ctx->config);\\n}\\n\\n\\/\\/ Attempt to get Client Config settigs\\n$settings = $csssweet->getClientConfigSettings($settings);\\n\\n\\/* Make settings available as [[++tags]] *\\/\\n$modx->setPlaceholders($settings, \'+\');\\n\\n\\/\\/ Parse chunk with $settings array\\n$contents = $csssweet->processChunks($chunks, $settings);\\n\\/\\/ If there\'s no result, what\'s the point?\\nif (empty($contents)) return;\\n\\n\\/\\/ CSS comments\\n$contents = \'\\/* Contents generated by MODX - this file will be overwritten. *\\/\' . PHP_EOL . $contents;\\n\\/\\/ The scssphp parser keeps comments with !\\nif (!$strip_comments) $contents = str_replace(\'\\/*\', \'\\/*!\', $contents);\\n\\n\\/\\/ Define target file\\n$file = $csssCustomCssPath . $filename;\\n\\n\\/\\/ Init scssphp\\n$scssMin = $csssweet->scssphpInit($scss_import_paths, $css_output_format);\\nif ($scssMin) {\\n\\n    try {\\n        $contents = $scssMin->compile($contents);\\n    }\\n    catch (Exception $e) {\\n        $modx->log(modX::LOG_LEVEL_ERROR, $e->getMessage() . \' scss not compiled. minification not performed.\',\'\',\'saveCustomCss\');\\n    }\\n\\n} else {\\n    $modx->log(modX::LOG_LEVEL_ERROR, \'Failed to load scss class. scss not compiled. minification not performed.\',\'\',\'saveCustomCss\');\\n}\\n\\n\\/\\/ If we failed scss and minification at least output what we have\\nfile_put_contents($file, $contents);\\nif (file_exists($file) && is_readable($file)) $modx->log(modX::LOG_LEVEL_INFO, \'Success! Custom CSS saved to file \\"\' . $file . \'\\"\', \'\', \'saveCustomCss\');","locked":0,"properties":"a:9:{s:11:\\"scss_chunks\\";a:7:{s:4:\\"name\\";s:11:\\"scss_chunks\\";s:4:\\"desc\\";s:77:\\"Name of chunk, or comma-separated list of chunks, from which to parse (S)CSS.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:20:\\"csss.custom_css.scss\\";s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:12:\\"css_filename\\";a:7:{s:4:\\"name\\";s:12:\\"css_filename\\";s:4:\\"desc\\";s:43:\\"Name of file to output custom compiled CSS.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:18:\\"custom_css.min.css\\";s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:8:\\"dev_mode\\";a:7:{s:4:\\"name\\";s:8:\\"dev_mode\\";s:4:\\"desc\\";s:16:\\"Enable DEV mode.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:6:\\"custom\\";s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:4:\\"Mode\\";}s:8:\\"css_path\\";a:7:{s:4:\\"name\\";s:8:\\"css_path\\";s:4:\\"desc\\";s:62:\\"Full path for directory to which to OUTPUT the final CSS file.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:24:\\"context_settings_context\\";a:7:{s:4:\\"name\\";s:24:\\"context_settings_context\\";s:4:\\"desc\\";s:79:\\"The key of a single context from which to pull context settings for CSS values.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:17:\\"minify_custom_css\\";a:7:{s:4:\\"name\\";s:17:\\"minify_custom_css\\";s:4:\\"desc\\";s:58:\\"Minify CSS on output. MUST be enabled for SCSS processing.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:1;s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:21:\\"SCSS and Minification\\";}s:17:\\"scss_import_paths\\";a:7:{s:4:\\"name\\";s:17:\\"scss_import_paths\\";s:4:\\"desc\\";s:99:\\"Optionally set import paths to check for SCSS imports. All @import paths must be relative to these.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:21:\\"SCSS and Minification\\";}s:24:\\"strip_css_comment_blocks\\";a:7:{s:4:\\"name\\";s:24:\\"strip_css_comment_blocks\\";s:4:\\"desc\\";s:69:\\"Strips CSS comment blocks on output, only IF minification is ENABLED.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:21:\\"SCSS and Minification\\";}s:17:\\"css_output_format\\";a:7:{s:4:\\"name\\";s:17:\\"css_output_format\\";s:4:\\"desc\\";s:98:\\"Choose either \'Expanded\' (default), \'Nested\' or \'Compact\' CSS output, IF minification is DISABLED.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:8:\\"Expanded\\";s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:21:\\"SCSS and Minification\\";}}","disabled":0,"moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * saveCustomCss\\n * @author @sepiariver\\n * Copyright 2013 - 2015 by YJ Tso <yj@modx.com> <info@sepiariver.com>\\n *\\n * saveCustomCss and cssSweet is free software;\\n * you can redistribute it and\\/or modify it under the terms of the GNU General\\n * Public License as published by the Free Software Foundation;\\n * either version 2 of the License, or (at your option) any later version.\\n *\\n * saveCustomCss and cssSweet is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License along with\\n * saveCustomCss and cssSweet; if not, write to the Free Software Foundation, Inc.,\\n * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\\n *\\n * @package cssSweet\\n *\\n *\\/\\n\\n\\/\\/ Never fire on the front end\\nif ($modx->context->get(\'key\') !== \'mgr\') return;\\n\\n\\/\\/ In case the wrong event is enabled in plugin properties\\n$allowedEvents = array(\'OnSiteRefresh\',\'OnChunkFormSave\',\'ClientConfig_ConfigChange\');\\nif (!in_array($modx->event->name, $allowedEvents)) return;\\n\\n\\/\\/ Grab the cssSweet class\\n$csssweet = null;\\n$cssSweetPath = $modx->getOption(\'csssweet.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/csssweet\\/\');\\n$cssSweetPath .= \'model\\/csssweet\\/\';\\nif (file_exists($cssSweetPath . \'csssweet.class.php\')) $csssweet = $modx->getService(\'csssweet\', \'CssSweet\', $cssSweetPath);\\n\\nif (!$csssweet || !($csssweet instanceof CssSweet)) {\\n\\n    $modx->log(modX::LOG_LEVEL_ERROR, \'[SaveCustomCss] could not load the required csssweet class!\');\\n\\treturn;\\n\\n}\\n\\n\\/\\/ Dev mode option\\n$mode = $modx->getOption(\'dev_mode\', $scriptProperties, \'custom\', true);\\n\\/\\/ Letting folks know what\'s going on\\n$modx->log(modX::LOG_LEVEL_INFO, \'saveCustomCss plugin is running in mode: \' . $mode);\\n\\n\\/\\/ Override properties with mode props\\n$properties = $scriptProperties;\\nforeach ($properties as $key => $val) {\\n    \\/\\/ skip any mode props\\n    if (strpos($key, $mode) === 0) continue;\\n    \\/\\/ these are standard scriptProperties\\n    $properties[$key] = (isset($properties[$mode . \'_\' . $key])) ? $properties[$mode . \'_\' . $key] : $val;\\n}\\n\\n\\/\\/ Specify a comma-separated list of chunk names in plugin properties\\n$chunks = $csssweet->explodeAndClean($modx->getOption(\'scss_chunks\', $properties, \'\'));\\n\\/\\/ If no chunk names specified, there\'s nothing to do.\\nif (empty($chunks)) {\\n    $modx->log(modX::LOG_LEVEL_WARN, \'No chunks were set in the saveCustomCss plugin property scss_chunks. No action performed.\');\\n    return;\\n}\\n\\n\\/\\/ Don\'t run this for every ChunkSave event\\nif ($modx->event->name === \'OnChunkFormSave\' && !in_array($chunk->get(\'name\'), $chunks)) return;\\n\\n\\/\\/ Specify an output file name in plugin properties\\n$filename = $modx->getOption(\'css_filename\', $properties, \'\');\\nif (empty($filename)) return;\\n\\n\\/\\/ Optionally choose an output format if not minified\\n$css_output_format = $modx->getOption(\'css_output_format\', $properties, \'Expanded\');\\n$css_output_format_options = array(\'Expanded\',\'Nested\',\'Compact\');\\nif (!in_array($css_output_format, $css_output_format_options)) $css_output_format = \'Expanded\';\\n\\n\\/\\/ Optionally minify the output, defaults to \'true\'\\n$minify_custom_css = (bool) $modx->getOption(\'minify_custom_css\', $properties, true);\\n$css_output_format = ($minify_custom_css) ? \'Compressed\' : $css_output_format;\\n\\n\\/\\/ Strip CSS comment blocks; defaults to \'false\'\\n$strip_comments = (bool) $modx->getOption(\'strip_css_comment_blocks\', $properties, false);\\n$css_output_format = ($minify_custom_css && $strip_comments) ? \'Crunched\' : $css_output_format;\\n\\n\\/\\/ Optionally set base_path for scss imports\\n$scss_import_paths = $modx->getOption(\'scss_import_paths\', $properties, \'\');\\n$scss_import_paths = (empty($scss_import_paths)) ? array() : $csssweet->explodeAndClean($scss_import_paths);\\n\\n\\/\\/ Get the output path; construct fallback; log for debugging\\n$csssCustomCssPath = $modx->getOption(\'css_path\', $properties, \'\');\\nif (empty($csssCustomCssPath)) $csssCustomCssPath = $modx->getOption(\'assets_path\') . \'components\\/csssweet\\/\' . $mode . \'\\/\';\\n$modx->log(modX::LOG_LEVEL_INFO, \'$csssCustomCssPath is: \' . $csssCustomCssPath . \' on line: \' . __LINE__);\\n$csssCustomCssPath = rtrim($csssCustomCssPath, \'\\/\') . \'\\/\';\\n\\n\\/\\/ If directory exists but isn\'t writable we have a problem, Houston\\nif (file_exists($csssCustomCssPath) && !is_writable($csssCustomCssPath)) {\\n    $modx->log(modX::LOG_LEVEL_ERROR, \'The directory at \' . $csssCustomCssPath . \'is not writable!\',\'\',\'saveCustomCss\');\\n    return;\\n}\\n\\n\\/\\/ Check if directory exists, if not, create it\\nif (!file_exists($csssCustomCssPath)) {\\n    if (mkdir($csssCustomCssPath, 0755, true)) {\\n        $modx->log(modX::LOG_LEVEL_INFO, \'Directory created at \' . $csssCustomCssPath, \'\', \'saveCustomCss\');\\n    } else {\\n        $modx->log(modX::LOG_LEVEL_ERROR, \'Directory could not be created at \' . $csssCustomCssPath, \'\', \'saveCustomCss\');\\n        return;\\n    }\\n}\\n\\n\\/\\/ Initialize settings array\\n$settings = array();\\n\\n\\/\\/ Get context settings\\n$settings_ctx = $modx->getOption(\'context_settings_context\', $properties, \'\');\\nif (!empty($settings_ctx)) {\\n    $settings_ctx = $modx->getContext($settings_ctx);\\n    if ($settings_ctx && is_array($settings_ctx->config)) $settings = array_merge($settings, $settings_ctx->config);\\n}\\n\\n\\/\\/ Attempt to get Client Config settigs\\n$settings = $csssweet->getClientConfigSettings($settings);\\n\\n\\/* Make settings available as [[++tags]] *\\/\\n$modx->setPlaceholders($settings, \'+\');\\n\\n\\/\\/ Parse chunk with $settings array\\n$contents = $csssweet->processChunks($chunks, $settings);\\n\\/\\/ If there\'s no result, what\'s the point?\\nif (empty($contents)) return;\\n\\n\\/\\/ CSS comments\\n$contents = \'\\/* Contents generated by MODX - this file will be overwritten. *\\/\' . PHP_EOL . $contents;\\n\\/\\/ The scssphp parser keeps comments with !\\nif (!$strip_comments) $contents = str_replace(\'\\/*\', \'\\/*!\', $contents);\\n\\n\\/\\/ Define target file\\n$file = $csssCustomCssPath . $filename;\\n\\n\\/\\/ Init scssphp\\n$scssMin = $csssweet->scssphpInit($scss_import_paths, $css_output_format);\\nif ($scssMin) {\\n\\n    try {\\n        $contents = $scssMin->compile($contents);\\n    }\\n    catch (Exception $e) {\\n        $modx->log(modX::LOG_LEVEL_ERROR, $e->getMessage() . \' scss not compiled. minification not performed.\',\'\',\'saveCustomCss\');\\n    }\\n\\n} else {\\n    $modx->log(modX::LOG_LEVEL_ERROR, \'Failed to load scss class. scss not compiled. minification not performed.\',\'\',\'saveCustomCss\');\\n}\\n\\n\\/\\/ If we failed scss and minification at least output what we have\\nfile_put_contents($file, $contents);\\nif (file_exists($file) && is_readable($file)) $modx->log(modX::LOG_LEVEL_INFO, \'Success! Custom CSS saved to file \\"\' . $file . \'\\"\', \'\', \'saveCustomCss\');"}',
        'guid' => '6743a4970079e72cb438b791e42d2f06',
        'native_key' => NULL,
        'signature' => '9ae62f20efcea80a606f537577317bde',
      ),
      'd7c585877d17dc01d31bc5687861db36' => 
      array (
        'unique_key' => 'name',
        'preserve_keys' => false,
        'update_object' => true,
        'related_objects' => 
        array (
          'PluginEvents' => 
          array (
            'f90c7f8143bbeb78594419b06276d728' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnSiteRefresh","priority":0,"propertyset":0}',
              'guid' => 'b014b31799b2f9b71c11d1452a09ecb0',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnSiteRefresh',
              ),
              'signature' => 'effc0c1ccb0d00300db65d89cc27a445',
            ),
            '201ce7eafe171089f3cfeb7e0a287f4b' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnChunkFormSave","priority":0,"propertyset":0}',
              'guid' => 'bf69ae8f5a81e9b7a0dcffcdb2ddefac',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnChunkFormSave',
              ),
              'signature' => 'bbdde36a723996bcc7264a6259f7487e',
            ),
          ),
        ),
        'related_object_attributes' => 
        array (
          'PluginEvents' => 
          array (
            'preserve_keys' => true,
            'update_object' => false,
            'unique_key' => 
            array (
              0 => 'pluginid',
              1 => 'event',
            ),
          ),
        ),
        'class' => 'modPlugin',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"saveCustomJs","description":"","editor_type":0,"category":0,"cache_type":0,"plugincode":"\\/**\\n * saveCustomJs\\n * @author @sepiariver\\n * Copyright 2013 - 2015 by YJ Tso <yj@modx.com> <info@sepiariver.com>\\n *\\n * saveCustomJs and cssSweet is free software;\\n * you can redistribute it and\\/or modify it under the terms of the GNU General\\n * Public License as published by the Free Software Foundation;\\n * either version 2 of the License, or (at your option) any later version.\\n *\\n * saveCustomJs and cssSweet is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License along with\\n * saveCustomJs and cssSweet; if not, write to the Free Software Foundation, Inc.,\\n * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\\n *\\n * @package cssSweet\\n *\\n *\\/\\n\\n\\/\\/ Never fire on the front end\\nif ($modx->context->get(\'key\') !== \'mgr\') return;\\n\\n\\/\\/ In case the wrong event is enabled in plugin properties\\n$allowedEvents = array(\'OnSiteRefresh\',\'OnChunkFormSave\',\'ClientConfig_ConfigChange\');\\nif (!in_array($modx->event->name, $allowedEvents)) return;\\n\\n\\/\\/ Grab the cssSweet clas\\n$csssweet = null;\\n$cssSweetPath = $modx->getOption(\'csssweet.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/csssweet\\/\');\\n$cssSweetPath .= \'model\\/csssweet\\/\';\\nif (file_exists($cssSweetPath . \'csssweet.class.php\')) $csssweet = $modx->getService(\'csssweet\', \'CssSweet\', $cssSweetPath);\\n\\nif (!$csssweet || !($csssweet instanceof CssSweet)) {\\n\\n    $modx->log(modX::LOG_LEVEL_ERROR, \'[SaveCustomCss] could not load the required csssweet class!\');\\n\\treturn;\\n\\n}\\n\\n\\/\\/ Dev mode option\\n$mode = $modx->getOption(\'dev_mode\', $scriptProperties, \'custom\', true);\\n\\/\\/ Letting folks know what\'s going on\\n$modx->log(modX::LOG_LEVEL_INFO, \'saveCustomJs plugin is running in mode: \' . $mode);\\n\\n\\/\\/ Override properties with mode props\\n$properties = $scriptProperties;\\nforeach ($properties as $key => $val) {\\n    \\/\\/ skip any mode props\\n    if (strpos($key, $mode) === 0) continue;\\n    \\/\\/ these are standard scriptProperties\\n    $properties[$key] = (isset($properties[$mode . \'_\' . $key])) ? $properties[$mode . \'_\' . $key] : $val;\\n}\\n\\n\\/\\/ Specify a comma-separated list of chunk names in plugin properties\\n$chunks = $csssweet->explodeAndClean($modx->getOption(\'js_chunks\', $properties, \'\'));\\n\\/\\/ If no chunk names specified, there\'s nothing to do.\\nif (empty($chunks)) {\\n    $modx->log(modX::LOG_LEVEL_WARN, \'No chunks were set in the saveCustomJs plugin property js_chunks. No action performed.\');\\n    return;\\n}\\n\\n\\/\\/ Don\'t run this for every ChunkSave event\\nif ($modx->event->name === \'OnChunkFormSave\' && !in_array($chunk->get(\'name\'), $chunks)) return;\\n\\n\\/\\/ Specify an output file name in plugin properties\\n$filename = $modx->getOption(\'js_filename\', $properties, \'\');\\nif (empty($filename)) return;\\n\\n\\/\\/ Optionally minify the output, defaults to \'true\'\\n$minify_custom_js = (bool) $modx->getOption(\'minify_custom_js\', $properties, true);\\n\\n\\/\\/ Strip comment blocks; defaults to \'false\'\\n$strip_comments = (bool) $modx->getOption(\'strip_js_comment_blocks\', $properties, false);\\n$preserve_comments = ($strip_comments) ? false : true;\\n\\n\\/\\/ Get the output path; construct fallback; log for info\\/debugging\\n$csssCustomJsPath = $modx->getOption(\'js_path\', $properties, \'\');\\nif (empty($csssCustomJsPath)) $csssCustomJsPath = $modx->getOption(\'assets_path\') . \'components\\/csssweet\\/\' . $mode . \'\\/js\\/\';\\n$modx->log(modX::LOG_LEVEL_INFO, \'$csssCustomJsPath is: \' . $csssCustomJsPath . \' on line: \' . __LINE__);\\n$csssCustomJsPath = rtrim($csssCustomJsPath, \'\\/\') . \'\\/\';\\n\\n\\/\\/ If directory exists but isn\'t writable we have a problem, Houston\\nif (file_exists($csssCustomJsPath) && !is_writable($csssCustomJsPath)) {\\n    $modx->log(modX::LOG_LEVEL_ERROR, \'The directory at \' . $csssCustomJsPath . \'is not writable!\');\\n    return;\\n}\\n\\n\\/\\/ Check if directory exists, if not, create it\\nif (!file_exists($csssCustomJsPath)) {\\n    if (mkdir($csssCustomJsPath, 0755, true)) {\\n        $modx->log(modX::LOG_LEVEL_INFO, \'Directory created at \' . $csssCustomJsPath);\\n    } else {\\n        $modx->log(modX::LOG_LEVEL_ERROR, \'Directory could not be created at \' . $csssCustomJsPath);\\n        \\/\\/ We can\'t continue in this case\\n        return;\\n    }\\n}\\n\\n\\/\\/ Initialize settings array\\n$settings = array();\\n\\n\\/\\/ Get context settings\\n$settings_ctx = $modx->getOption(\'context_settings_context\', $properties, \'\');\\nif (!empty($settings_ctx)) {\\n    $settings_ctx = $modx->getContext($settings_ctx);\\n    if ($settings_ctx && is_array($settings_ctx->config)) $settings = array_merge($settings, $settings_ctx->config);\\n}\\n\\n\\/\\/ Attempt to get Client Config settigs\\n$settings = $csssweet->getClientConfigSettings($settings);\\n\\n\\/* Make settings available as [[++tags]] *\\/\\n$modx->setPlaceholders($settings, \'+\');\\n\\n\\/\\/ Parse chunk with $settings array\\n$contents = $csssweet->processChunks($chunks, $settings);\\n\\n\\/\\/ If there\'s no result, what\'s the point?\\nif (empty($contents)) return;\\n\\n\\/\\/ Comments\\n$contents = \'\\/* Contents generated by MODX - this file will be overwritten. *\\/\' . PHP_EOL . $contents;\\nif ($preserve_comments) {\\n    \\/\\/ Add \'!\' token to preserve all comments\\n    $contents = str_replace(array(\'\\/*\',\'\\/*!\'), \'\\/*!\', $contents);\\n} else {\\n    \\/\\/ We discard flagged comments if the strip_js_comment_blocks property is true. Good idea or no?\\n    $contents = str_replace(\'\\/*!\', \'\\/*\', $contents);\\n}\\n\\n\\/\\/ Define target file\\n$file = $csssCustomJsPath . $filename;\\n\\n\\/\\/ Status report\\n$status = \'not\';\\nif ($minify_custom_js) {\\n\\n\\t\\t$jshrink = $csssweet->jshrinkInit();\\n\\n\\t    \\/\\/ If we got the class, try minification. Log failures.\\n\\t    if ($jshrink) {\\n\\n\\t        try {\\n\\t            $contents = $jshrink::minify($contents, array(\'flaggedComments\' => $preserve_comments));\\n\\t            $status = \'\';\\n\\t        }\\n\\t        catch (Exception $e) {\\n\\t            $modx->log(modX::LOG_LEVEL_ERROR, $e->getMessage() . \'\\u2014 js not compiled. Minification not performed.\');\\n\\t        }\\n\\n\\t    } else {\\n\\t        $modx->log(modX::LOG_LEVEL_ERROR, \'Failed to load js Minifier class \\u2014 js not compiled. Minification not performed.\');\\n\\t    }\\n\\n}\\n\\n\\/\\/ None of the minifiers seem to handle this correctly?\\n$contents = str_replace(\'!function\', PHP_EOL . \'!function\', $contents);\\n\\n\\/\\/ If we didnt\' minify, output what we have\\nfile_put_contents($file, $contents);\\nif (file_exists($file) && is_readable($file)) $modx->log(modX::LOG_LEVEL_INFO, \'Minification was \'. $status . \' performed. Custom JS saved to file: \' . $file);","locked":0,"properties":"a:7:{s:9:\\"js_chunks\\";a:7:{s:4:\\"name\\";s:9:\\"js_chunks\\";s:4:\\"desc\\";s:73:\\"Name of chunk, or comma-separated list of chunks, from which to parse JS.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:11:\\"js_filename\\";a:7:{s:4:\\"name\\";s:11:\\"js_filename\\";s:4:\\"desc\\";s:42:\\"Name of file to output custom compiled JS.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:16:\\"custom_js.min.js\\";s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:8:\\"dev_mode\\";a:7:{s:4:\\"name\\";s:8:\\"dev_mode\\";s:4:\\"desc\\";s:16:\\"Enable DEV mode.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:6:\\"custom\\";s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:4:\\"Mode\\";}s:7:\\"js_path\\";a:7:{s:4:\\"name\\";s:7:\\"js_path\\";s:4:\\"desc\\";s:61:\\"Full path for directory to which to OUTPUT the final JS file.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:24:\\"context_settings_context\\";a:7:{s:4:\\"name\\";s:24:\\"context_settings_context\\";s:4:\\"desc\\";s:79:\\"The key of a single context from which to pull context settings for CSS values.\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:16:\\"minify_custom_js\\";a:7:{s:4:\\"name\\";s:16:\\"minify_custom_js\\";s:4:\\"desc\\";s:20:\\"Minify JS on output.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:1;s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:12:\\"Minification\\";}s:23:\\"strip_js_comment_blocks\\";a:7:{s:4:\\"name\\";s:23:\\"strip_js_comment_blocks\\";s:4:\\"desc\\";s:35:\\"Strips JS comment blocks on output.\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";s:19:\\"csssweet:properties\\";s:4:\\"area\\";s:12:\\"Minification\\";}}","disabled":0,"moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * saveCustomJs\\n * @author @sepiariver\\n * Copyright 2013 - 2015 by YJ Tso <yj@modx.com> <info@sepiariver.com>\\n *\\n * saveCustomJs and cssSweet is free software;\\n * you can redistribute it and\\/or modify it under the terms of the GNU General\\n * Public License as published by the Free Software Foundation;\\n * either version 2 of the License, or (at your option) any later version.\\n *\\n * saveCustomJs and cssSweet is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License along with\\n * saveCustomJs and cssSweet; if not, write to the Free Software Foundation, Inc.,\\n * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\\n *\\n * @package cssSweet\\n *\\n *\\/\\n\\n\\/\\/ Never fire on the front end\\nif ($modx->context->get(\'key\') !== \'mgr\') return;\\n\\n\\/\\/ In case the wrong event is enabled in plugin properties\\n$allowedEvents = array(\'OnSiteRefresh\',\'OnChunkFormSave\',\'ClientConfig_ConfigChange\');\\nif (!in_array($modx->event->name, $allowedEvents)) return;\\n\\n\\/\\/ Grab the cssSweet clas\\n$csssweet = null;\\n$cssSweetPath = $modx->getOption(\'csssweet.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/csssweet\\/\');\\n$cssSweetPath .= \'model\\/csssweet\\/\';\\nif (file_exists($cssSweetPath . \'csssweet.class.php\')) $csssweet = $modx->getService(\'csssweet\', \'CssSweet\', $cssSweetPath);\\n\\nif (!$csssweet || !($csssweet instanceof CssSweet)) {\\n\\n    $modx->log(modX::LOG_LEVEL_ERROR, \'[SaveCustomCss] could not load the required csssweet class!\');\\n\\treturn;\\n\\n}\\n\\n\\/\\/ Dev mode option\\n$mode = $modx->getOption(\'dev_mode\', $scriptProperties, \'custom\', true);\\n\\/\\/ Letting folks know what\'s going on\\n$modx->log(modX::LOG_LEVEL_INFO, \'saveCustomJs plugin is running in mode: \' . $mode);\\n\\n\\/\\/ Override properties with mode props\\n$properties = $scriptProperties;\\nforeach ($properties as $key => $val) {\\n    \\/\\/ skip any mode props\\n    if (strpos($key, $mode) === 0) continue;\\n    \\/\\/ these are standard scriptProperties\\n    $properties[$key] = (isset($properties[$mode . \'_\' . $key])) ? $properties[$mode . \'_\' . $key] : $val;\\n}\\n\\n\\/\\/ Specify a comma-separated list of chunk names in plugin properties\\n$chunks = $csssweet->explodeAndClean($modx->getOption(\'js_chunks\', $properties, \'\'));\\n\\/\\/ If no chunk names specified, there\'s nothing to do.\\nif (empty($chunks)) {\\n    $modx->log(modX::LOG_LEVEL_WARN, \'No chunks were set in the saveCustomJs plugin property js_chunks. No action performed.\');\\n    return;\\n}\\n\\n\\/\\/ Don\'t run this for every ChunkSave event\\nif ($modx->event->name === \'OnChunkFormSave\' && !in_array($chunk->get(\'name\'), $chunks)) return;\\n\\n\\/\\/ Specify an output file name in plugin properties\\n$filename = $modx->getOption(\'js_filename\', $properties, \'\');\\nif (empty($filename)) return;\\n\\n\\/\\/ Optionally minify the output, defaults to \'true\'\\n$minify_custom_js = (bool) $modx->getOption(\'minify_custom_js\', $properties, true);\\n\\n\\/\\/ Strip comment blocks; defaults to \'false\'\\n$strip_comments = (bool) $modx->getOption(\'strip_js_comment_blocks\', $properties, false);\\n$preserve_comments = ($strip_comments) ? false : true;\\n\\n\\/\\/ Get the output path; construct fallback; log for info\\/debugging\\n$csssCustomJsPath = $modx->getOption(\'js_path\', $properties, \'\');\\nif (empty($csssCustomJsPath)) $csssCustomJsPath = $modx->getOption(\'assets_path\') . \'components\\/csssweet\\/\' . $mode . \'\\/js\\/\';\\n$modx->log(modX::LOG_LEVEL_INFO, \'$csssCustomJsPath is: \' . $csssCustomJsPath . \' on line: \' . __LINE__);\\n$csssCustomJsPath = rtrim($csssCustomJsPath, \'\\/\') . \'\\/\';\\n\\n\\/\\/ If directory exists but isn\'t writable we have a problem, Houston\\nif (file_exists($csssCustomJsPath) && !is_writable($csssCustomJsPath)) {\\n    $modx->log(modX::LOG_LEVEL_ERROR, \'The directory at \' . $csssCustomJsPath . \'is not writable!\');\\n    return;\\n}\\n\\n\\/\\/ Check if directory exists, if not, create it\\nif (!file_exists($csssCustomJsPath)) {\\n    if (mkdir($csssCustomJsPath, 0755, true)) {\\n        $modx->log(modX::LOG_LEVEL_INFO, \'Directory created at \' . $csssCustomJsPath);\\n    } else {\\n        $modx->log(modX::LOG_LEVEL_ERROR, \'Directory could not be created at \' . $csssCustomJsPath);\\n        \\/\\/ We can\'t continue in this case\\n        return;\\n    }\\n}\\n\\n\\/\\/ Initialize settings array\\n$settings = array();\\n\\n\\/\\/ Get context settings\\n$settings_ctx = $modx->getOption(\'context_settings_context\', $properties, \'\');\\nif (!empty($settings_ctx)) {\\n    $settings_ctx = $modx->getContext($settings_ctx);\\n    if ($settings_ctx && is_array($settings_ctx->config)) $settings = array_merge($settings, $settings_ctx->config);\\n}\\n\\n\\/\\/ Attempt to get Client Config settigs\\n$settings = $csssweet->getClientConfigSettings($settings);\\n\\n\\/* Make settings available as [[++tags]] *\\/\\n$modx->setPlaceholders($settings, \'+\');\\n\\n\\/\\/ Parse chunk with $settings array\\n$contents = $csssweet->processChunks($chunks, $settings);\\n\\n\\/\\/ If there\'s no result, what\'s the point?\\nif (empty($contents)) return;\\n\\n\\/\\/ Comments\\n$contents = \'\\/* Contents generated by MODX - this file will be overwritten. *\\/\' . PHP_EOL . $contents;\\nif ($preserve_comments) {\\n    \\/\\/ Add \'!\' token to preserve all comments\\n    $contents = str_replace(array(\'\\/*\',\'\\/*!\'), \'\\/*!\', $contents);\\n} else {\\n    \\/\\/ We discard flagged comments if the strip_js_comment_blocks property is true. Good idea or no?\\n    $contents = str_replace(\'\\/*!\', \'\\/*\', $contents);\\n}\\n\\n\\/\\/ Define target file\\n$file = $csssCustomJsPath . $filename;\\n\\n\\/\\/ Status report\\n$status = \'not\';\\nif ($minify_custom_js) {\\n\\n\\t\\t$jshrink = $csssweet->jshrinkInit();\\n\\n\\t    \\/\\/ If we got the class, try minification. Log failures.\\n\\t    if ($jshrink) {\\n\\n\\t        try {\\n\\t            $contents = $jshrink::minify($contents, array(\'flaggedComments\' => $preserve_comments));\\n\\t            $status = \'\';\\n\\t        }\\n\\t        catch (Exception $e) {\\n\\t            $modx->log(modX::LOG_LEVEL_ERROR, $e->getMessage() . \'\\u2014 js not compiled. Minification not performed.\');\\n\\t        }\\n\\n\\t    } else {\\n\\t        $modx->log(modX::LOG_LEVEL_ERROR, \'Failed to load js Minifier class \\u2014 js not compiled. Minification not performed.\');\\n\\t    }\\n\\n}\\n\\n\\/\\/ None of the minifiers seem to handle this correctly?\\n$contents = str_replace(\'!function\', PHP_EOL . \'!function\', $contents);\\n\\n\\/\\/ If we didnt\' minify, output what we have\\nfile_put_contents($file, $contents);\\nif (file_exists($file) && is_readable($file)) $modx->log(modX::LOG_LEVEL_INFO, \'Minification was \'. $status . \' performed. Custom JS saved to file: \' . $file);"}',
        'guid' => '9da4676f1e175f8f0ac4cbe87062177c',
        'native_key' => NULL,
        'signature' => '445c7c9e7ae8003f9059860fe6d6026e',
      ),
    ),
  ),
  'related_object_attributes' => 
  array (
    'Children' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 
      array (
        0 => 'parent',
        1 => 'category',
      ),
    ),
    'Snippets' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Chunks' => 
    array (
      'preserve_keys' => false,
      'update_object' => false,
      'unique_key' => 'name',
    ),
    'Templates' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'templatename',
    ),
    'TemplateVars' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Plugins' => 
    array (
      'unique_key' => 'name',
      'preserve_keys' => false,
      'update_object' => true,
      'related_objects' => true,
      'related_object_attributes' => 
      array (
        'PluginEvents' => 
        array (
          'preserve_keys' => true,
          'update_object' => false,
          'unique_key' => 
          array (
            0 => 'pluginid',
            1 => 'event',
          ),
        ),
      ),
    ),
  ),
  'namespace' => 'csssweet',
  'resolve' => 
  array (
    0 => 
    array (
      'type' => 'file',
      'body' => '{"source":"csssweet-4.2.0-rc3\\/modCategory\\/c136d2348b3b607abdad9026534a40dc\\/0\\/","target":"return MODX_ASSETS_PATH . \'components\\/\';","name":"csssweet"}',
    ),
    1 => 
    array (
      'type' => 'file',
      'body' => '{"source":"csssweet-4.2.0-rc3\\/modCategory\\/c136d2348b3b607abdad9026534a40dc\\/1\\/","target":"return MODX_CORE_PATH . \'components\\/\';","name":"csssweet"}',
    ),
  ),
  'validate' => NULL,
  'vehicle_package' => 'transport',
  'vehicle_class' => 'xPDOObjectVehicle',
  'guid' => '64e1f16b5f817567e2a95f0831870ad7',
  'package' => 'modx',
  'class' => 'modCategory',
  'signature' => 'c136d2348b3b607abdad9026534a40dc',
  'native_key' => NULL,
  'object' => '{"id":null,"parent":0,"category":"cssSweet","rank":0}',
);